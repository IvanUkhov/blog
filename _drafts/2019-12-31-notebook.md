---
layout: post
title: Notebooks in tightly sealed, disposable, immutable containers
date: 2019-12-31
keywords:
  - Docker
  - JupyterLab
  - Python
  - R
  - RStudio
  - data science
---

It is truly amazing how interactive notebooks—where narratives in spoken
languages are entwined with executable chunks of code in programming
languages—have revolutionized the way we work with data and document our thought
processes and findings for others and, equally importantly, for our future
selves. They are ubiquitous and taken for granted. It is hard to imagine where
data enthusiasts would be without them. Most likely, we would be spending way
too much time staring at a terminal window, anxiously re-running scripts from
start to finish, printing variables, and saving lots of files with tables and
graphs on disk for further inspection. Interactive notebooks are an essential
tool in the data scientist’s toolbox, and in this article, we are going to make
them readily available with our preferences set up and our favorite software
packages installed, no matter where we find ourselves working and regardless of
the mess we might have left behind during the previous session.

Python and R (in alphabetic order) are arguably the main languages used by data
scientists now-a-days. In the context of interactive computation, [IPython] and
later on [Project Jupyter] have been of paramount importance for the Python
community (the latter is actually language agnostic). In the R community, this
role is played by [RStudio]. Therefore, having at our disposal [JupyterLab],
which is Project Jupyter’s flagship, and RStudio should make us well equipped
for a wide range of data challenges. As alluded to earlier, the objective is to
make interactive notebooks, powered by JupyterLab and RStudio, available at our
fingertips starting from a fixed initial state, including user preferences and
software packages, and even independent of the machine we happen to work on.
This problem definition is a perfect fit for [Docker]. More specifically, we
shall containerize JupyterLab and RStudio and create a few convenient shortcuts
for launching them.

The code discussed below can be found in the following two repositories:

* [JupyterLab][JupyterLab/] and
* [RStudio][RStudio/].

# JupyterLab

In order to build a Docker image for JupyterLab, we begin with a
[`Dockerfile`][JupyterLab/Dockerfile]:

```docker
# Start with a minimal Python image
FROM python:3.7-slim

# Install the desired Python packages
COPY requirements.txt /tmp/requirements.txt
RUN pip install --upgrade pip
RUN pip install --upgrade --requirement /tmp/requirements.txt

# Configure JupyterLab to use a specific IP address and port
RUN mkdir -p ~/.jupyter
RUN echo "c.NotebookApp.ip = '0.0.0.0'" >> ~/.jupyter/jupyter_notebook_config.py
RUN echo "c.NotebookApp.port = 8888" >> ~/.jupyter/jupyter_notebook_config.py

# Set the working directory
WORKDIR /home

# Stort JupyterLab once the container is launched
ENTRYPOINT jupyter lab --allow-root --no-browser
```

In words, we take a minimalistic image with the desired version of Python
preinstalled—in this case, it is the [official Python image][Python] tagged
`3.7-slim`, which refers to Python 3.7 with any available bug fixes promptly
applied—and add packages that we consider to be important for our work. These
packages are gather in the usual [`requirements.txt`], which might look as
follows:

```
# Required
jupyterlab

# Optional
matplotlib
numpy
pandas
pylint
pytest
scikit-learn
scipy
seaborn
tensorflow
yapf
```

The first one, `jupyterlab`, is essential; the rest is up to the data
scientist’s taste. An important aspect to note is that, in this example, the
versions of the listed packages are not fixed; hence, the latest available
versions will be taken each time a new image is built. Alternatively, one can
pin them to specific numbers by changing `requirements.txt`. For instance, one
might write `tensorflow==1.14.0` instead of `tensorflow`.

Having defined an image, we need a tool for orchestration. Specifically, we
would like to have a simple command for actually building the image and, more
importantly, a simple command for launching a container with that image in an
arbitrary directory. The versatile `make` to the rescue!

```make
# The name of the Docker image
name := jupyterlab
# The directory to be mounted to the container
root ?= ${PWD}

# Build a new image
build:
	docker rmi ${name} || true
	docker build --tag ${name} .

# Start a new container
start:
	@docker run --interactive --tty --rm \
		--name ${name} \
		--publish 8888:8888 \
		--volume "${root}:/home" \
		${name}
```

In this [`Makefile`], we define two commands: `build` and `start`. The `build`
command instructs Docker to delete the image, if it already exits, and build a
new one. The `start` command launches a new container and mounts the directory
specified by the `root` variable to the file system inside the container using
the `--volume` option. It also forwards port 8888 inside the container, which is
the one specified in `Dockerfile`, to port 8888 on the host machine so that
JupyterLab becomes reachable from the browser.

Let us now go ahead and try the two commands:

```sh
make build
make start
```

JupyterLab should come back to you with usage instructions similar to the
following:

```
...
[I 18:40:15.078 LabApp] The Jupyter Notebook is running at:
[I 18:40:15.078 LabApp] http://e4edba021595:8888/?token=<token>
[I 18:40:15.078 LabApp]  or http://127.0.0.1:8888/?token=<token>
[I 18:40:15.078 LabApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
[C 18:40:15.082 LabApp]

    To access the notebook, open this file in a browser:
        file:///root/.local/share/jupyter/runtime/nbserver-6-open.html
    Or copy and paste one of these URLs:
        http://e4edba021595:8888/?token=<token>
     or http://127.0.0.1:8888/?token=<token>
...
```

By clicking on the last like, we end up in JupyterLab. Congratulations! However,
there is one step left. JupyterLab is currently running in the folder with our
`Dockerfile` and `Makefile`, which is not particularly useful. Fortunately, it
is easy to fix with an alias:

```sh
alias jupyterlab='make -C /path/to/the/folder/with/the/Makefile root="${PWD}"'
```

This command should be placed in the start-up script of the shell used, such as
`~/.bashrc` for Bash, which can be conveniently done as follows:

```sh
echo "alias jupyterlab='make -C \"${PWD}\" root=\"\${PWD}\"'" >> ~/.bashrc
```

Now, in a new terminal, one should be able to run JupyterLab from any directory
as follows:

```sh
cd /path/to/some/project
jupyterlab
```

# RStudio

Now it is time to get to grips with an image for RStudio.

# Conclusion

Images can be pushed to public or private repositories.

[JupyterLab/Dockerfile]: https://github.com/chain-rule/JupyterLab/blob/master/Dockerfile
[JupyterLab/]: https://github.com/chain-rule/JupyterLab
[RStudio/]: https://github.com/chain-rule/RStudio
[`Makefile`]: https://github.com/chain-rule/JupyterLab/blob/master/Makefile
[`requirements.txt`]: https://github.com/chain-rule/JupyterLab/blob/master/requirements.txt

[Docker]: https://www.docker.com/
[IPython]: https://ipython.org/
[JupyterLab]: https://jupyter.org/
[Project Jupyter]: https://jupyter.org/
[Python]: https://hub.docker.com/_/python
[RStudio]: https://www.rstudio.com/
